# Civiapp – Programma Punti Fedeltà (brief per implementazione)

## 0) Visione rapida
- Programma punti per salone con ratio configurabile (default 1 punto ogni 10 €) e tetto di riscatto al 30% del valore della vendita.
- Saldo cliente salvato in `clients.loyaltyPoints` e movimenti in `/clients/{id}/loyalty_movements`, sincronizzati dall'app tramite `AppDataStore`.
- La schermata `SaleFormSheet` propone automaticamente l'utilizzo dei punti disponibili, calcolando sconto e importo residuo nel rispetto dei limiti.
- Le vendite salvano un riepilogo `loyalty` per evitare doppi accrediti; una Cloud Function applica le variazioni al profilo cliente e registra i movimenti.
- Un job annuale resetta i punti nella data definita per salone e crea movimenti di scadenza per audit.

## 1) Configurazione per salone
- Aggiungere in `lib/domain/entities/salon.dart` la value object immutabile `LoyaltySettings` (e relative sotto-strutture `LoyaltyEarningRules`, `LoyaltyRedemptionRules`, `LoyaltyExpirationRules`).
- `LoyaltySettings` è opzionale: quando `enabled == false` la UI disabilita qualsiasi blocco fedeltà e il backend non accredita punti.
- Campi richiesti:
  - `enabled` (bool, default `false`).
  - `earning.euroPerPoint` (double, default `10`), `earning.rounding` (`floor`|`round`|`ceil`, default `floor`).
  - `redemption.pointValueEuro` (double, default `1`) e `redemption.maxPercent` (double 0-1, default `0.30`).
  - `redemption.autoSuggest` (bool, default `true`) per abilitare la proposta automatica in UI.
  - `initialBalance` (int, default `0`) applicato alla creazione del cliente.
  - `expiration.resetMonth` (1-12), `expiration.resetDay` (1-31) e `expiration.timezone` (default `Europe/Rome`).
  - `updatedAt` (DateTime) per tracciare l'ultima modifica.
- Aggiornare `lib/data/mappers/firestore_mappers.dart` (metodi `salonFromDoc` / `salonToMap`) per serializzare il nuovo blocco.
- `lib/presentation/screens/admin/forms/salon_form_sheet.dart`: inserire card "Programma fedeltà" con:
  - switch on/off del programma;
  - `TextFormField` numerici per rapporto punti/€ e tetto percentuale;
  - date picker (giorno/mese) per la scadenza annuale;
  - validazioni (e.g. `maxPercent <= 0.5`, `euroPerPoint >= 1`).
- `lib/presentation/screens/admin/modules/salon_management_module.dart`: mostrare riepilogo sintetico (stato programma, rapporto punti, data reset).

## 2) Modello dati Firestore
```
/salons/{salonId}
  name: string
  ...
  loyaltySettings: {
    enabled: bool
    earning: {
      euroPerPoint: number
      rounding: "floor" | "round" | "ceil"
    }
    redemption: {
      pointValueEuro: number
      maxPercent: number        // es. 0.30
      autoSuggest: bool
    }
    initialBalance: number
    expiration: {
      resetMonth: number        // 1-12
      resetDay: number          // 1-31
      timezone: string
    }
    updatedAt: Timestamp
  }

clients/{clientId}
  salonId: string
  firstName: string
  ...
  loyaltyPoints: number
  loyaltyUpdatedAt?: Timestamp
  loyaltyTotalEarned?: number
  loyaltyTotalRedeemed?: number

sales/{saleId}
  salonId: string
  clientId: string
  total: number
  discountAmount: number       // sconto manuale + sconto fedeltà
  loyalty: {
    redeemedPoints: number
    redeemedValue: number
    eligibleAmount: number     // base € dopo sconti e riscatto
    requestedEarnPoints: number
    requestedEarnValue: number
    processedMovementIds: [string]   // popolato dal backend
    earnedPoints: number
    earnedValue: number
    netPoints: number                 // earnedPoints - redeemedPoints
    computedAt: Timestamp
    version: 1
  }

clients/{clientId}/loyalty_movements/{movementId}
  salonId: string
  type: "earning" | "redemption" | "expiration" | "adjustment"
  source: "sale" | "manual" | "system"
  points: number             // positivo per accrediti, negativo per addebiti
  euroValue: number
  saleId?: string
  paymentMovementId?: string
  operatorId?: string
  operatorName?: string
  note?: string
  createdAt: Timestamp
  balanceAfter: number
  metadata?: {
    eligibleAmount?: number
    ratio?: number
    maxPercent?: number
  }
```
- Aggiungere indice Firestore per ordinare `loyalty_movements` per `createdAt DESC`.
- Aggiornare `firestore.rules` per permettere ad admin/staff la lettura del sottoinsieme e impedire scrittura diretta lato client su `loyalty_movements`.

## 3) Flussi applicativi

### 3.1 Accredito punti automatico
1. Introdurre `LoyaltyCalculator` (`lib/domain/loyalty/loyalty_calculator.dart`) che, dato `SaleDraft`, `Client`, `LoyaltySettings` e l'elenco dei `SalePaymentMovement`, costruisce `SaleLoyaltySummary` (eligible amount, punti richiesti, punti da riscattare, ecc.).
2. `SaleFormSheet` (creazione vendita) e la gestione incassi successivi (`OutstandingPaymentFormSheet` in `client_detail_page.dart`) usano il calcolatore per:
   - Settare `sale.loyalty.redeemedPoints` / `redeemedValue` / `eligibleAmount`.
   - Calcolare `requestedEarnPoints` e `requestedEarnValue` in base a `earning.euroPerPoint` e `rounding`.
   - Lasciare vuoto `processedMovementIds`, che sarà popolato dal backend.
3. `AppDataStore.upsertSale` salva sempre il blocco `loyalty` insieme alla vendita.
4. Cloud Function `syncLoyaltyOnSaleWrite` (`functions/src/loyalty/onSaleWrite.ts`):
   - Trigger `onWrite` su `sales/{saleId}`; ignora se `loyalty` assente o `loyaltySettings.enabled == false`.
   - Recupera `salon.loyaltySettings` e `client.loyaltyPoints`.
   - Calcola nuovi accrediti analizzando `paymentHistory`:
     - Elenca i movement `SalePaymentMovement` non presenti in `processedMovementIds`.
     - Per ciascun movimento, calcola `points = floor(amount / euroPerPoint)` (applicando eventuale arrotondamento definito).
     - Accumula `earnedDelta` e aggiorna `processedMovementIds`.
   - Gestisce il totale dei punti richiesti (`requestedEarnPoints`) per differenze di arrotondamento e aggiorna `earnedPoints`, `earnedValue`, `netPoints`.
   - Esegue una transazione Firestore che:
     - Aggiorna `clients/{clientId}` (saldo, contatori e timestamp).
     - Crea uno o più documenti in `loyalty_movements` con `type` appropriato e `paymentMovementId`.
     - Aggiorna lo stesso documento `sales/{saleId}` con il nuovo array `processedMovementIds`, `earnedPoints`, `earnedValue`, `netPoints` e `computedAt`.
   - In caso di errore ripristina il campo `computedAt` precedente per facilitare retry idempotente.
5. Ogni qualvolta una vendita viene eliminata (`AppDataStore.deleteSale`), invocare una Cloud Function `rollbackLoyaltyForSale` per stornare i punti associati (anche tramite trigger `onDelete`).

### 3.2 Riscatto punti in fase di pagamento
- Nella UI di vendita, dopo il riepilogo totale, aggiungere sezione "Programma fedeltà":
  - Mostrare saldo attuale (`client.loyaltyPoints`), soglia massima utilizzabile e punti suggeriti (se `autoSuggest` è true).
  - Calcolare `maxRedeemableEuro = eligibleAmountPrimaDelRiscatto * maxPercent`.
  - `maxRedeemablePoints = floor(maxRedeemableEuro / pointValueEuro)`.
  - Limite finale = `min(client.loyaltyPoints, maxRedeemablePoints)`.
  - Se l'operatore modifica manualmente sconto totale o rimuove articoli, ricalcolare il limite in tempo reale.
- Lo sconto derivante dai punti va memorizzato separatamente in `sale.loyalty.redeemedValue` ma influisce su `discountAmount` totale mostrato all'utente (somma di sconto manuale + fedeltà).
- Il valore scelto viene salvato in `sale.loyalty.redeemedPoints` e inviato a Firestore; la Cloud Function sottrae i punti dal saldo cliente creando movimento `type: redemption`.

### 3.3 Scadenza annuale
- Nuova Cloud Function `scheduleLoyaltyReset` (`functions/src/loyalty/reset_scheduler.ts`):
  - Trigger Cloud Scheduler quotidiano alle 03:00 timezone `Europe/Rome`.
  - Per ogni salone con programma attivo e data di reset uguale alla data corrente:
    - Esegue transazione batched su tutti i clienti del salone: porta `loyaltyPoints` a `initialBalance` (o 0), crea movimento `type: expiration` con nota "Reset annuale", aggiorna contatori aggregati.
    - Registra log in collezione `loyalty_jobs` con report eseguito.
- In UI admin, mostrare la data di reset imminente e l'ultimo job eseguito.

### 3.4 Creazione / import di clienti
- `lib/presentation/screens/admin/forms/client_form_sheet.dart`: all'atto della creazione di un nuovo cliente, precompilare `loyaltyPoints` con `salon.loyaltySettings.initialBalance` e impedire di salvarlo vuoto.
- `lib/presentation/screens/auth/onboarding_screen.dart`: al termine dell'onboarding client, quando viene creato il documento cliente, impostare `loyaltyPoints` al valore iniziale.
- Ogni import massivo (tool CLI, se esiste) deve utilizzare lo stesso default.

## 4) UI e UX da aggiornare
- `lib/presentation/screens/admin/forms/sale_form_sheet.dart`:
  - Aggiungere card "Programma fedeltà" con saldo, input `TextFormField` o `Slider` per punti da utilizzare e label con euro equivalenti.
  - Integrare il sale summary per mostrare `Sconto fedeltà` e `Totale da incassare`.
  - Validare che i punti inseriti non superino `maxRedeemablePoints` e siano multipli di 1.
  - Serializzare i valori nello stesso oggetto `SaleLoyaltySummary` restituito dal calcolatore.
- `lib/presentation/screens/admin/modules/sales_module.dart`:
  - Aggiornare `_SummaryTile` per aggiungere card "Punti assegnati oggi" (sommando i movimenti `earning` di giornata).
  - Quando si apre un ticket con vendita precompilata, la modale deve ricalcolare i limiti fedeltà partendo dall'importo atteso.
- `lib/presentation/screens/admin/modules/client_detail_page.dart`:
  - Estendere il `TabBar` aggiungendo tab "Punti".
  - Nuova vista con:
    - saldo corrente e punti in scadenza (calcolando se il reset è prossimo);
    - tabella o `ListView` dei movimenti usando `StreamProvider` dedicato;
    - pulsante admin "Aggiusta manualmente" che apre bottom sheet per aggiungere o sottrarre punti (questa azione chiama Cloud Function `adjustClientLoyalty`).
  - Nella tab "Fatturazione" mostrare badge con punti assegnati/riscattati per ogni vendita.
- `lib/presentation/screens/admin/modules/clients_module.dart`: aggiungere colonna con saldo punti e filtro "ha punti disponibili".
- App cliente (`lib/presentation/screens/client/client_dashboard_screen.dart`):
  - Mostrare nel header il saldo punti e i movimenti principali (almeno gli ultimi 5) per coerenza con requisito "sincronizzazione app e backend".

## 5) Layer dominio, repository e provider
- Nuove entità:
  - `lib/domain/entities/loyalty_settings.dart` (separate dalla classe `Salon` per riuso).
  - `lib/domain/entities/loyalty_movement.dart` con `copyWith`, `fromDoc` ecc.
  - `lib/domain/loyalty/loyalty_calculator.dart` (metodo statico `computeSummary`).
- `lib/domain/entities/sale.dart`:
  - Aggiungere la value object `SaleLoyaltySummary loyalty`.
  - Aggiornare costruttore, `copyWith`, getter `outstandingAmount`, `saleToMap` / `saleFromDoc`.
- `lib/data/mappers/firestore_mappers.dart`:
  - Serializzare `SaleLoyaltySummary`.
  - Aggiungere conversioni per `LoyaltyMovement`.
- `lib/data/repositories/app_data_state.dart`:
  - Aggiungere campo `Map<String, List<LoyaltyMovement>> loyaltyMovements` oppure un cache provider ridotto (per evitare caricare tutto in memoria).
- `lib/data/repositories/app_data_store.dart`:
  - Metodo `Stream<List<LoyaltyMovement>> watchClientLoyaltyMovements(String clientId)` che ascolta la subcollection ordinata per `createdAt`.
  - Metodo `Future<void> adjustClientLoyalty({required String clientId, required int points, required String reason})` che invoca Cloud Function `adjustClientLoyalty`.
  - In `upsertSale` e in `deleteSale`, orchestrare chiamate HTTP callable per forzare il ricalcolo lato backend se serve (in caso di salvataggio offline).
- Riverpod:
  - Nuovo `StreamProvider.autoDispose.family<List<LoyaltyMovement>, String>` per popolare la tab punti.
  - Aggiornare `appDataProvider` selection per includere i totali (es. `totalLoyaltyEarnedForSalon`).

## 6) Backend Firebase
- Creare cartella `functions/src/loyalty`.
  - `onSaleWrite.ts`: trigger e logica di sincronizzazione descritta sopra.
  - `adjustClientLoyalty.ts`: HTTPS callable (auth admin/staff) che aggiunge movimento manuale e aggiorna saldo in transazione.
  - `reset_scheduler.ts`: job programmato.
  - `utils.ts`: helper per recuperare `loyaltySettings` e normalizzare arrotondamenti.
- Aggiornare `functions/src/index.ts` per esportare i nuovi trigger/callable.
- Integrare test unitari (`functions/test/loyalty.spec.ts`) per assicurare idempotenza e rispetto dei limiti.
- `firestore.rules`:
  - Consentire lettura `loyalty_movements` a ruoli admin/staff del salone, vietare scrittura diretta lato client.
  - Consentire all'app client la lettura dei propri movimenti (`request.auth.uid == resource.data.clientUid` se previsto).

## 7) Checklist sviluppo e QA
- Aggiornare schemi Dart e UI amministratore seguendo le sezioni 1, 4 e 5.
- Implementare le Cloud Functions e configurare Cloud Scheduler (aggiornare `firebase.json` se necessario).
- Scrivere unit test Dart:
  - `loyalty_calculator_test.dart` con casi (totale, tetto 30%, arrotondamenti, saldo insufficiente).
  - Test widget su `SaleFormSheet` per verifica limite punti.
- Verificare esplicitamente:
  - Creazione vendita con riscatto punti.
  - Incasso acconto + saldo in due step.
  - Eliminazione vendita e rollback del saldo.
  - Reset annuale simulato (invocando manualmente la funzione con data forzata).
  - Visione lato cliente del saldo aggiornato.
- Documentare in `README.md` la procedura di configurazione (attivare Cloud Scheduler, variables per timezone) e aggiungere screenshot UI nella cartella `civiappdoc/punti fedeltà/`.

## 8) Questioni definite
- Confermare con il business se 1 punto può avere un fattore moltiplicativo configurabile.
- In caso di reset annuale non ci sono storni o resi da fare.
- I clienti possono vedere punti in scadenza e ricevere notifiche (non previsto in questa iterazione).
